@page "/"
@using System.Xml.Linq
@inject IJSRuntime JSRuntime
@inject SharedDataService SharedDataService

<h3>Fiszki</h3>
<!-- Sekcja: Wybór pliku XML -->
<InputFile OnChange="OnFileSelected" />

@if (!string.IsNullOrEmpty(fileName))
{
    SharedDataService.fileName = fileName;
}


@if (SharedDataService.Pairs.Count > 0)
{
    <h5 class="mt-3">Załadowany plik: @SharedDataService.fileName</h5>

    <h4>Rozpoznawanie mowy</h4>
    <p>Tekst: @recognizedText</p>
    <input @bind="listenLanguage" placeholder="Wpisz kod języka (np. en-US)" style="width:300px;" />


    <h4>Język fiszek</h4>
    <div class="mb-2">
        <input @bind="speakLanguage" placeholder="Wpisz kod języka (np. en-US)" style="width:300px;" />
    </div>


    <button class="btn btn-success" @onclick="() => StartRandomMode(listenLanguage)" disabled="@isRandomModeRunning">Start</button>
    <button class="btn btn-danger" @onclick="() => StopRandomMode()" disabled="@(!isRandomModeRunning)">Zatrzymaj</button>

}

@code {
    private string recognizedText = "Oczekiwanie na tekst...";
    private string listenLanguage = "";
    private bool isRandomModeRunning = false;
    private CancellationTokenSource? randomModeCancellationTokenSource;

    private async Task StartListening(String listenLanguage)
    {
        var dotNetReference = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("speechRecognitionInterop.startListening", dotNetReference, listenLanguage);
        StateHasChanged();
    }

    [JSInvokable]
    public void ProcessSpeech(string transcript)
    {

        recognizedText = transcript;
        StateHasChanged();
    }

    private string textToSpeak = "";
    private string speakLanguage = ""; // Domyślny język

    private async Task SpeakText(string speakLanguage)
    {
        try
        {
            // Wywołanie JS z czekaniem na zakończenie odtwarzania
            await JSRuntime.InvokeVoidAsync("speechSynthesisInterop.speak", textToSpeak, speakLanguage);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd podczas odtwarzania tekstu: {ex.Message}");
        }
    }


    private string? fileName;

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.GetMultipleFiles(1).FirstOrDefault();
        if (file == null) return;

        fileName = file.Name;

        using var stream = file.OpenReadStream(maxAllowedSize: 10_000_000);
        using var reader = new StreamReader(stream);
        var xmlContent = await reader.ReadToEndAsync();

        LoadPairsFromXml(xmlContent);
    }

    private void LoadPairsFromXml(string xml)
    {
        SharedDataService.Pairs.Clear();

        try
        {
            var xdoc = XDocument.Parse(xml);
            foreach (var el in xdoc.Descendants("pair"))
            {
                var front = el.Element("front")?.Value;
                var back = el.Element("back")?.Value;

                if (!string.IsNullOrEmpty(front) && !string.IsNullOrEmpty(back))
                {
                    SharedDataService.Pairs.Add(new SharedDataService.FlashcardPair
                        {
                            FrontSide = front,
                            BackSide = back
                        });
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Błąd parsowania XML: " + ex.Message);
        }
    }

    private async Task StartRandomMode(String listenLanguage)
    {
        if (SharedDataService.Pairs.Count == 0)
            return;

        isRandomModeRunning = true;
        StateHasChanged();
        randomModeCancellationTokenSource = new CancellationTokenSource();
        var token = randomModeCancellationTokenSource.Token;

        try
        {
            while (!token.IsCancellationRequested)
            {
                var random = new Random();
                var randomIndex = random.Next(SharedDataService.Pairs.Count);
                var randomPair = SharedDataService.Pairs[randomIndex];

                textToSpeak = randomPair.FrontSide;
                await SpeakText(speakLanguage);

                // Czekaj 10 sekund
                await JSRuntime.InvokeVoidAsync("playSound", "./Assets/waiting-for-response.mp3");
                await Task.Delay(300, token);
                StartListening(listenLanguage);
                await Task.Delay(5000, token);

                //Console.WriteLine(recognizedText.Substring(0, recognizedText.Length - 1));
                //Console.WriteLine(randomPair.BackSide);
                if (recognizedText.Substring(0, recognizedText.Length - 1).ToLower() == "stop")
                {
                    throw new TaskCanceledException();
                }
                if (recognizedText.Substring(0, recognizedText.Length - 1).ToLower() == randomPair.BackSide.ToLower())
                {
                    await JSRuntime.InvokeVoidAsync("playSound", "./Assets/good-answer.mp3");
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("playSound", "./Assets/wrong-answer.mp3");
                    await Task.Delay(500);
                    textToSpeak = randomPair.BackSide;
                    await SpeakText(listenLanguage);
                }


                await Task.Delay(2000, token);
            }
        }
        catch (TaskCanceledException)
        {
            // Task został anulowany - zakończ pętlę
        }
        finally
        {
            isRandomModeRunning = false;
            StateHasChanged();
        }
    }

    private void StopRandomMode()
    {
        randomModeCancellationTokenSource?.Cancel();
        randomModeCancellationTokenSource = null;
        isRandomModeRunning = false;
        StateHasChanged();
    }
}
